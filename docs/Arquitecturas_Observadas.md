Arquitectura General del Sistema

La importancia estratégica del proyecto reside en su arquitectura dual, que separa inteligentemente la fase de entrenamiento, computacionalmente intensiva, de la fase de ejecución, que debe ser ligera y eficiente. Esta separación es fundamental para implementar una solución de inteligencia artificial en un dispositivo con recursos de hardware limitados, como es una placa Arduino. El modelo se entrena en un entorno de alto rendimiento (offline) y luego se despliega en el vehículo para la toma de decisiones en tiempo real (online).

El flujo de trabajo general del sistema se puede visualizar en dos fases principales:

Fase 1: Entrenamiento del Modelo (Entorno Python):
Se define la estructura de la red neuronal (capas, neuronas y función de activación).
Se prepara un conjunto de datos de entrenamiento que mapea escenarios de entrada (distancia y posición del obstáculo) con acciones de salida deseadas (activación de motores).
La red neuronal se entrena utilizando el algoritmo de retropropagación (backpropagation) en un entorno Python, ajustando sus pesos internos a lo largo de miles de iteraciones hasta que el error es mínimo.
El resultado de esta fase es un conjunto de matrices de pesos (HiddenWeights y OutputWeights) que encapsulan el "conocimiento" aprendido por la red.
Fase 2: Despliegue e Inferencia (Entorno Arduino):
Las matrices de pesos generadas en Python se transfieren manualmente al código fuente de Arduino.
El código de Arduino implementa únicamente la lógica de propagación hacia adelante (forward propagation).
En tiempo real, el coche captura datos de sus sensores, los normaliza y los introduce en la red.
La red utiliza los pesos pre-entrenados para realizar cálculos (sumas y multiplicaciones) y generar una salida, que se traduce directamente en comandos para los motores. El Arduino no realiza ningún tipo de aprendizaje; solo ejecuta el modelo ya entrenado.
Arquitectura de Software: La Red Neuronal

La red neuronal es el "cerebro" del vehículo, responsable de procesar la información sensorial y tomar decisiones de conducción autónoma. Su diseño, entrenamiento y despliegue son los pilares que sustentan la capacidad del coche para navegar sin intervención humana directa. Estructura y Configuración del Modelo La topología de la red neuronal es una arquitectura multicapa relativamente sencilla, optimizada para su función específica:

• Capa de Entrada: 2 neuronas, que reciben los datos normalizados de los sensores. • Capa Oculta: 3 neuronas, que procesan la información de entrada para extraer características relevantes. • Capa de Salida: 4 neuronas, donde cada neurona controla directamente uno de los cuatro motores del vehículo.

La función de activación seleccionada para todas las capas es la tangente hiperbólica (tanh), que produce salidas en un rango de -1 a 1, un formato coherente con los datos de entrada normalizados. Es importante destacar que la implementación en el código de Arduino considera una neurona de BIAS adicional, configurando la capa de entrada con InputNodes = 3 y la capa oculta con HiddenNodes = 4 para mejorar la capacidad de aprendizaje del modelo durante el entrenamiento. Arquitectónicamente, la inclusión de la unidad de BIAS es crucial, ya que permite a la red desplazar la función de activación, aumentando significativamente la flexibilidad y capacidad del modelo para aprender mapeos complejos que no pasan necesariamente por el origen.

Entradas de la Red Neuronal

Salidas de la Red Neuronal

Las combinaciones de estas salidas binarias se traducen en las siguientes acciones concretas del vehículo: • Avanzar: Se activan los motores 1 y 4. • Retroceder: Se activan los motores 2 y 3. • Giro Derecha: Se activan los motores 2 y 4. • Giro Izquierda: Se activan los motores 1 y 3.

Proceso de Entrenamiento (Offline en Python) El entrenamiento se realiza íntegramente en Python antes de que el código se cargue en el Arduino. Se utiliza un conjunto de datos (X e y) compuesto por 9 ejemplos cuidadosamente seleccionados. Este conjunto de datos mapea explícitamente diferentes escenarios de detección de obstáculos (p. ej., "obstáculo demasiado cerca a la derecha") a la combinación de salidas motoras deseadas (p. ej., "retroceder").

Arquitectura de Hardware: El Vehículo Robótico

La arquitectura de hardware es la manifestación física del sistema. La selección y el ensamblaje correctos de los componentes son fundamentales para que el vehículo pueda percibir su entorno de manera fiable y actuar sobre él de forma efectiva. Listado de Componentes Esenciales El vehículo se construye a partir de un conjunto de componentes estándar en robótica y electrónica: • Placa Arduino (Uno o Mega): Actúa como el microcontrolador central del sistema. Es la unidad que aloja y ejecuta el código de la red neuronal, procesando las entradas de los sensores y enviando comandos a los motores. • Controlador de Motor L298N: Es una interfaz de potencia (puente H) indispensable que se sitúa entre la lógica de control de bajo voltaje del Arduino y los motores DC de alto consumo. Su función es amplificar la corriente de los pines de E/S del microcontrolador para poder gobernar la velocidad (mediante PWM) y la dirección de giro de las cargas inductivas que representan los motores. • Motores DC (4 o 2): Son los actuadores que proporcionan la propulsión y la capacidad de giro al vehículo. El sistema está diseñado para 4 motores, pero es adaptable a 2. • Servo Motor SG90: Un pequeño motor de precisión cuya función es orientar el sensor ultrasónico, permitiéndole escanear el entorno en lugar de apuntar a una única dirección fija. • Sensor Ultrasónico: Es el principal sensor de percepción del vehículo. Mide la distancia a los objetos emitiendo un pulso de sonido y midiendo el tiempo que tarda en regresar el eco. • Baterías, Chasis y Cables: Componentes de soporte esenciales que proporcionan la alimentación eléctrica, la estructura mecánica y las conexiones necesarias para integrar todo el sistema. Ensamblaje Físico y Funcionalidad del Sensor La configuración física más crítica del diseño es el montaje del sensor ultrasónico sobre el servo motor, ubicado en la parte delantera del chasis. Este ensamblaje transforma un sensor de distancia estático en un sistema de percepción dinámico.

El propósito de esta configuración es crear un sistema de "radar" simple. El servo motor barre continuamente de izquierda a derecha en un rango angular predefinido (ANGULO_MIN a ANGULO_MAX). En cada posición, el sensor ultrasónico mide la distancia. Esta combinación permite al coche no solo saber qué tan lejos está un obstáculo, sino también en qué dirección se encuentra, proporcionando las dos entradas cruciales que alimentan la red neuronal. Para que el sistema funcione, es imprescindible entender cómo el software y el hardware interactúan en un ciclo continuo, lo cual se detalla en la siguiente sección.

Arquitectura de Integración: Flujo de Control y Datos

Esta sección es clave para comprender el funcionamiento dinámico y en tiempo real del sistema. Detalla el ciclo completo de operación, uniendo el software (la red neuronal) y el hardware (sensores y motores) en un bucle de percepción-decisión-acción que produce el comportamiento autónomo. Un pilar de esta arquitectura de integración es el uso de un bucle no bloqueante basado en la función millis(), que permite al microcontrolador gestionar el movimiento del servo y la lógica de conducción de manera concurrente, una práctica esencial en el diseño de sistemas embebidos en tiempo real. Ciclo de Operación en Tiempo Real El flujo de control principal se implementa dentro de las funciones loop() y conducir() del código de Arduino, ejecutando los siguientes pasos de forma cíclica y continua:

Escaneo del Entorno: La función loop() principal se ejecuta repetidamente. Su primera tarea es gestionar el movimiento del servo motor, haciendo que el sensor ultrasónico barra el área frontal del coche entre los ángulos ANGULO_MIN y ANGULO_MAX.
Captura de Datos: A intervalos regulares, definidos por la variable interval, se invoca la función conducir(). Lo primero que hace esta función es llamar a Distance_test() para obtener una lectura de la distancia actual al obstáculo más cercano en la dirección que apunta el sensor.
Normalización de Entradas: Los datos brutos del sensor (distancia en centímetros y el ángulo actual del servo en grados) no son aptos para la red neuronal. El código los procesa y normaliza para convertirlos en las dos entradas (entrada1, entrada2), escalándolos a un rango de -1 a 1.
Cálculo de Tiempo de Reacción Adaptativo: Inmediatamente después de normalizar la distancia, se calcula la variable accionEnCurso. Este valor determina cuántos ciclos de loop() se dedicarán a ejecutar la maniobra actual. Es directamente proporcional a la cercanía del obstáculo, lo que ingeniosamente le da al vehículo más tiempo para girar o retroceder cuando el peligro es inminente.
Inferencia de la Red Neuronal: Con las entradas normalizadas y la unidad de BIAS, se invoca a la función InputToOutput(). Esta función ejecuta el proceso de propagación hacia adelante, procesando las entradas a través de las capas oculta y de salida utilizando los pesos pre-entrenados para calcular los cuatro valores de salida.
Decisión y Actuación: Las salidas de la red, que son valores continuos, se procesan para tomar una decisión binaria. Se aplica la función abs() porque la salida de la activación tanh puede ser negativa, y luego se redondea (round()) para convertir el valor resultante en una decisión binaria inequívoca (0 o 1) para el control del motor.
Control de Motores: Estos cuatro valores binarios (0 o 1) se utilizan para activar o desactivar directamente los pines digitales (IN1 a IN4) conectados al controlador L298N. Esto, a su vez, suministra o corta la energía a los cuatro motores, produciendo el movimiento físico del coche: avanzar, retroceder o girar. Este ciclo de integración, que se repite decenas de veces por segundo, es lo que permite al vehículo reaccionar de forma fluida y autónoma a un entorno cambiante.
Conclusión y Mejoras Futuras

La principal conclusión de este proyecto es la demostración práctica de la viabilidad de implementar Machine Learning en un dispositivo físico con recursos limitados. El resultado es un coche que aprende a tomar decisiones de navegación por sí mismo, evitando obstáculos sin depender de un conjunto de instrucciones explícitas y rígidas de tipo "if-then". Esto abre la puerta a la creación de sistemas más inteligentes y adaptables. El diseño actual sirve como una base sólida sobre la cual se pueden implementar numerosas mejoras futuras: • Incorporación de más sensores: Se podrían añadir sensores infrarrojos para detectar bordes, sensores de velocidad en las ruedas, o incluso sensores de luz y sonido. Esto enriquecería las entradas del modelo, permitiéndole tomar decisiones más informadas y complejas. • Simplificación del Mantenimiento: Una de las mayores ventajas de la arquitectura neuronal es su escalabilidad. Para incorporar los nuevos sensores mencionados, no sería necesario reescribir complejas lógicas de control. Bastaría con añadir nuevas "features" (columnas) al conjunto de datos de entrenamiento y volver a entrenar el modelo. El proceso de despliegue seguiría siendo el mismo: copiar los nuevos pesos al Arduino. • Adaptación a Otro Hardware: El sistema es flexible. Podría adaptarse fácilmente para un coche con solo 2 motores. Para ello, únicamente se necesitaría modificar la capa de salida de la red para que tuviera 2 neuronas en lugar de 4 y reentrenar el modelo con un conjunto de datos adecuado para esa configuración.
